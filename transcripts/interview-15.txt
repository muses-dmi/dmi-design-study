---
# Note: This is a metadata section formatted in YAML. This document can be rendered as markdown for better readability.

participant: 15
role: Software engineer / Audio developer
experience(years): 6
instrument_count: 5

instruments:
 - Ableton Live
 - Ableton Push
 - Ableton Simpler /Sampler / Wavetable

langugaes:
 - c
 - c++
 - python

---

# Why do you use your chosen programming language(s)?

Right, so the programming languages I use on an everyday basis are c++ for performance reasons. Mostly since there are like libraries that enable access, they enable access to like processor level optimizations, right? And yeah, you can take control over your own memory layout. But also because of how it integrates with other tools like Max, for instance, because you can write your own externals in C or c++, like, audio plugin API's and so on. Right. So this would be the main reason why I, or people I work with continue using c++, I believe. The other one would be Python. Because first of all, I think this is still the most relevant reason, I am fluent in it. Like, it's my like, it's been my language of choice for many years. So if you're comfortable in it, and I'm fast in it, and this is important to me to be able to prototype fast, and also has a lot of built in and external libraries available for quick data manipulation operations on the data matrices, and so on. So let's say he, when it comes to programming languages, that would be it, c++ for performance reasons, and for its relevance within the field and Python for because of my own preference, and the abundance of tools and little helpers, I can use that speed my processes up.

Pretty much yeah.

> Is there any kind of interplay between the Python and c++?

Also, like, I think I will mention that when we move on to the tools, but like, in Python, I can just quickly draw a window and expose a button and like change some parameters in real time, or plot curves and analyse them and quickly splayed in mean, like Jupyter Notebook or something. So it's so yeah, it's just way faster for me since like, I treat Python like people treat MATLAB.

> when you move an idea between Python and c++, is that a seamless process for you? Or do you find that anything gets lost in that translation?

I'm not sure I'd use the word translation there. Because I use Python, like since I said, I use it for prototyping purposes. I don't necessarily like I would rethink, like, when I think of the actual implementation, or rethink the whole thing, prototyping only serves the purpose of validating an idea, let's say, so, for me, it's just like starting over, really, having validated the idea and said,

# Why do you use your chosen tools for instrument design?

so let's say, right, I mentioned Jupyter Notebook already, because of its seamless integration with Python. And yeah, as I said, for me, the toolset it offers makes it a good alternative and like free alternative to MATLAB and performance wise is also very similar. So yeah, it even offers like a clone of the signal processing library from MATLAB. So yeah, let's say for these reasons that I can quickly examing examine the outcomes of my computations and yeah, just plot some characteristics and see what's happening. Then also, like, I'd say, Why Did I choose it because I think it's a popular tool within the data science community in the Python world. And that's the community, I used to be close to, So also because of my own exposure. And I also would say I use Max. Also, because how it because it gives me a lot of tools out of the box and modules that I can freely connect with each other in the way I want. And it's customizable, so I can write my own c++ code and integrated with it quite quickly. Well, once you've gotten familiar with the API, it's quicker, but there's some learning curve involved. But I'd say because of that, because this is how I always consider a good framework. It lets you do simple things quickly, but also lets you customise it in the way you want. It doesn't have to be simple, but it's allowed. It's possible. So so this is why use max, then another reason why we use max of Ableton, for instance, is because of also the affiliation of Ableton with Cycling 74. So yeah, I'd say actually, the popularity of tools also, like plays a role makes a difference, right? Because also, they offer more solutions, then and you can find answers to your questions quicker when there's a big community around it. So that's definitely not not something to be neglected. And. Right, but other than that, it's also like he had just as I mentioned, just because of how many little helpers I have out of the box, and how well I can customise it the same goes to Python, like everything Python related interpreter, notebook, is open source, I can just like change whatever I need whenever I need it. So that's Yeah, this would be the reasons I'd say.

> Yeah. For hardware. Do you use anything like 3d printers as you mentioned them previously?

I don't it's used as Ableton for prototyping hardware. But I personally don't write since I don't work on. Well, I have worked on even for hardware devices, I have worked on the software side. So so I don't but like yeah, 3d printing is used at Ableton for it or like an CNC machine. That's definitely used. 

# Why did you chose your chosen platform(s) to build your instrument on?

Right. So as platforms I named operating system systems for personal computers. I mostly work on Mac OSX, I have to embrace windows too. But these platforms are chosen because they're the most relevant platforms for the target of our products. And for people who use our product. So because of the audio performance on Mac OS platforms, because of like their Yeah, the work Apple's doing on making sure that the experience of using audio applications on Mac is actually of a certain standard. Yeah, people in the music world use Mac computers, and probably this is maybe still Windows users is our still biggest the biggest part of our user base, but like, yeah, Windows and Mac OS are by far our most popular platforms, we just have to cater for these users needs. I'd say yeah, just for these reasons thinking of the user first.

# Are there any other tools (software or otherwise) that you feel contributes significantly to your process?

So any other tools? Since I've mentioned Max already, and my prototyping environments, I don't think there's anything else that would stand out necessarily, I don't know if something will come up later.

# What would be the biggest 'Quality of Life' improvement you could request from your tools for designing DMI?

For me, the biggest thing is anything that enables rapid prototyping that like, and the trickiest thing is something that makes it easier to plug into the existing legacy systems. So like, Yeah. Which is like something I have to deal with, right, like, actually experiment and prototype on top of like, large legacy systems. And it's actually quite a tricky thing to do. Right? So for me, this is most important how to, yeah, explore new ideas when dealing with Yeah, already these like large code bases written in C or c++. Could be like, I don't know, like, maybe even something that quickly enables me to export my prototypes to like a plugin in a known format is already useful, right? So because also, for me, it's like, then it can be distributed to many users quickly for testing with users. Getting frequent user feedback is super important to me. So I think that would be the biggest one just because to me, the biggest issue that I encounter many times is that first of all, how do you? Yeah, how do you prototype quicker, always quicker, like, you know, the most important thing is to like, drop the idea when it's not good early, like, you know, so you don't create too much waste, and then just like, being able to validated the idea, as soon as possible and move on,  And but then what's equally important is to be able not to only evaluate the idea myself, but also be able to distribute the prototype to other people. And it's, this is tricky, because like, when you actually have like something I don't know, like, some blocks connected together, and you just like, listen to it yourself. It's fine. But like, how do I give it to other people so that they can hear I have to bundle it in a plugin, I have to like, I don't know, have a working max or max for live device, which is already somewhat polished. But like, if this process could be sped up, then I think this would be the biggest one for me.

# How do you approach the design of a new instrument?

So for me, it's always important to check if I know the why and what-for, and it's like, what am I actually doing? What am I trying to accomplish? What expression will this instrument enable? Does it need to be different from other things that they're being offered currently? And if so, in what way? And also like who it is for, right? Um, for me, the beauty of modern instrument designs is that they let me express my like, I don't know, everyday life contemporary struggles, like you know, like living in this like, industrial environment of a big Rapid City and I don't know, I don't thing it's easily can be, but like, it's not easily expressed for me like, it's not satisfying when it's expressed on the violin and the flute, like, you know, it's like, I need like, very noisey synthesisers to enable this. So even thinking about this, like, What's that, that we're missing in the contemporary context? Yeah, so like, first of all, just like checking why, and Who is it for? Definitely, that's most important to always see this bigger picture that I can refer back to, in the process. As then it's typing and going through a few iterations until it's good, right. And then choosing the most convincing path, building an MVP, and constantly refining it. And then I think was also very important is to leave some leave it open ended. So making sure that it's structured in a way that allows extensibility that it can get better over time. Like, can be refined after being released to the public. So yeah. So I think that that would be a tricky one. Like some of the instruments, like actual instrument devices we have in Ableton Live For instance, are maybe like, not easily extensible. And now we can't actually modernise it so easily, as easily as we would like to. And I think, the big disadvantage of it, yeah, something to keep in mind from the very beginning, I think.

# When creating a new instrument, what distinct aspects are required to realize the design and implementation?

So this is this is where maybe I could use guidance, which direction would be interesting, what aspects are required to realise the design implementation? Um, I mean, to? Do you mean to actually, like, even start or finish it? Like, you know, what, which like, are we talking about, like, all stages are what is supposed to.

> I think it's, this question is about, realising what you intended to create. So is there some set of generalisable things that you do with all instruments that allows you to actually realise the thing you intended to create?

So since I mentioned that, my intention, intention is usually to cater for a certain need. And the need represents a need of a certain group of people, it's important for me to always like, get a lot of feedback. So like, user research is very important. And user tests, let's say, and they always inform the design and implementation a lot. What's interesting is that implementation and design for me are pretty intertwined. They always affect each other. And I've had interesting situations when I was trying to implement a design. And the implementation was so quirky, that it led to questioning the design, and in a good way. So it was like, yeah, maybe if the implementation has to be this, there's something like, wrong with a design and and it was true, because like it was actually a feature was implementing on push. And it was designed by an instrument designer who didn't design for push before. So it was like breaking a paradigm but maybe shouldn't be breaking this paradigm. So we started like discussing it and actually redesigned the feature. So there was actually really interesting experience and also But he may be the other way around design informing the implementation is more straightforward. And But yeah, I am, what I really like is this like, is the creation of an instrumented device by constantly thinking of both. So even if the team building something consists of designers and engineers in different roles, the collaboration is always very strong. And I think this is actually really important. And also some, sometimes like different implementation choices, like open up more opportunities, right, or adding some more functionality. So like, for me, it's like, very close, and it's random, but like, but I also believe that, as I said before, like maybe structuring things in a modular way, so that different components can be quickly replaced is also very important, because during the refinement process, after addressing people's feedback, that's gonna change a lot. So if that if like, the design and implementations is created in a way that allows actually quickly like exploring different ideas, different corners, and quickly changing these things, I think the overall product like the end product benefits from it a lot. So how to call distinct aspects. I think I'd say, I don't know I could call modularity also for that, like, you know, that this, like, totally having this, like, loosely coupled components is what makes things way easier. And then let's say user feedback. A constant user feedback is important because also when we lose the user out of sight words, then becomes useless or it's in headaches.

# What do you consider to be the biggest challenge when designing an instrument?

I think I'm gonna go back to what I said before, how to validate the idea quickly without over investing, how to fail early when it's not convincing. And I also have an example here, I was exploring a new idea, which was like more of that generative instrument, was trying to repurpose like a technique widely used in 3d texture generation into like in the audio domain. Like also following some guides published somewhere, it was fractional Brownian motion, right. And I was thinking, Okay, that sounds really cool. I'm gonna explore this. And I was thinking, since I'll want to parameterize it and hear the effects of the parameter change in real time, I'll just quickly like sketch a small app that lets me just tweak the parameters on the fly. And I was like, Okay, I'm gonna do it in c++, since there's there's some computations going on. So that's not lagging and then sketching, sketching this simple window. Application just took me so long I just completely dropped it. I was like, so, so angry that I can't even get into exploring my idea because of like, because the tools and after Yeah, go to working after like a full day and I was like, Okay, this is, is I'm not doing this anymore. I switched to Python. And I just like, quickly hacked it together in like 10 minutes. So it was a and then actually yeah. For the algorithm in, check the results and they were very disappointing. It didn't sound interesting at So I was actually glad that I could just validate it rather earlier than later. But like, but for me this is it like, actually the fear of finding out this is the wrong path very late in the process is something that's the worst the most I'd say. Yeah. Because also like this is in my like, when writing software, the waste is actually not as big as when building hardware for instance. Right. So actually doing the wrong move when building hardware is more costly, I'd say. Yeah, so it's, again, better prototyping environments for me always.

Yeah.

# What tools do (or could) play the biggest part in helping with these challenges?

Yeah, as I said, like a prototyping tools. Definitely. I'd say, yeah, I think I'm gonna repeat what I said before that prototyping tools that actually also let you plug into existing systems faster. Or like, when building hardware, maybe the it's something that lets you I don't know quickly test, how you would delay out or how you would use it. When it comes to software, it's like something that lets you use it in the context you're going to be using it with. It's hard for me to imagine what it could be. Now like, for Ableton Live, it may be a plugin for any any DAW's . It can be like a max for like device. For other maybe when we write something gin, generative, maybe like if we could quickly open it in the browser that's already helpful. Anyway, I think like, anything that opens, I'm super excited about all these, like webassembly, and so on. Those that will, hopefully in the future let you like, ship your prototype to a broader audience fast, because when you open it in the browser, no setup is needed. It's super portable. It's just yeah, I think it's fantastic. Like, you know, so the portability, like prototype environments that allow portability, and yes, just quick integration with what exists and with the context, you're going to be using it in whatever that is. It's, I think, would be a big one for me.

> And just for clarity, because I think you've got an interesting point that you kind of mentioned earlier. It's, it's all about validation and feedback for you in the prototyping phase, right? It's like, it's not necessarily even about the prototype being a product that turns into the final product. I mean, I guess it would be nice if whatever you prototype was also eventually the end product, but maybe you're just being pragmatic In saying that, that's probably never gonna happen?

I think because of... so for me, doesn't sound very feasible, because maybe I'm just being pessimistic. But since we're dealing with Okay, so my domain is writing audio software that runs in real time on personal computers, not only specialist hardware, which is tricky, right? Because like, yeah, personal computers created to cater for the average scenario, but we actually have to meet the deadline in the worst case scenario. And so and so like, a lot of optimization techniques are needed there. And performance matters. And performance doesn't have to matter so much in the prototype, and I don't want it to matter, it can drop out sometimes. It's okay, it's acceptable, but it's not acceptable in the end product. So I think the process would be very different. Well, if there was something very, like, you know, if there were tools allowing us to create instruments, they're very performance on these platforms, which are like personal computers easily.

Maybe if like, I could prototype very quickly in c++, and automatically, it would just like, I don't know, plug into all the optimization libraries for me, then maybe that would be beneficial, but at the same time, I just think that Yeah, I just think that for me, it's still a very separate process and maybe it should stay separate. This is I think about it because of how I approach things like everything has to be polished from the beginning to the end product, but like in the prototyping phase, you actually deliberately skip all that. And sometimes it's actually hard to go back and I didn't. Yeah, I just think that the way of thinking about doing things is pretty different. Like, when you look at the prototype, you can like, use your imagination be like, yeah, I imagined it's there. Inside there, it's fine, or, like, have a placeholder button or something, and it's completely fine. Or, like, Oh, this is a little glitchy, but like, you know, you get the idea. And it's, I wouldn't be want to be deprived of this also have the privilege of thinking like this in this like, limited realm also. So for me, this is why the prototyping phase is completely different to Yeah, to the implementation. Phase. Yeah, that said,

I have built some small, instruments instruments only for like, educational reasons, purposes. That only had just one implementation. There was like a prototype turned the end product, but like the performance was equally unimportant. And because it was just for educational purposes, so. So yeah, like long story short, I doubt it's feasible, I maybe pesimistick.

# How would you define a DMI?

Think I'm gonna be equally vague. Okay, for It's said to me, it's like, physical or virtual device, for lack of a better word, that enables expression of musical ideas. And, and maybe I want to create audible output or enables creating audible output. And, or, like, create output that can be made audible, let's put in. So So yeah, basically to Yeah, and to me, it can be a synthesiser workstation, or a piece of hardware or a neural network, or Yeah. Also vague. Like anything that enables Yeah, that lets you transform your musical idea into something audible.

# What concepts do you consider a DMI to be made up from?

Yeah, so definitely, like an interface that enables like, putting ideas in right, so whatever the interface and it can be, like, something that lets you interact with the, or like something that lets you express your ideas directly, or maybe something like an interface that lets you set expectations or an interface that lets you parameterize it when the instrument does not let you be creative. The instrument itself is created for like a neural network, right? So I'd like you how you would like to be able to parameterize it play with it a little bit. So yes, so this user interface definitely. And then, so for me only like two elements are always present. So like this, the key and interface and then an output basically, and as I said, the output doesn't have to be audible it can be like a MIDI note, right? So like output that can be translated to something audible. So I think these are the key only two universal things that they find necessary to for something to be called an instrument and the rest is like a playground and can be anything 

# Any other comments?

Um Yeah, I wanted to ask you if you wanted me to like explore anything in more detail but other than that I'm not sure I have anything else to contribute other than saying that like an Ableton we call push an instrument we call Ableton Live and instrument we call a studio an instrument. 

Yeah. I mean, this is how we approach it definitely like Ableton live is an instrument for us digital audio workstation, like we think of it as a digital audio workstation as an instrument this way. also define it as, like, to me a digital instrument is like something that enables your creative expression and whatever it is, is up for debate, like whatever makes it possible, like, you know, I don't know maybe an ATM with beeping keys is already instrument I don't know, like, whatever however you use it. Like I think you're the way you use it is like also matters. It's just Yeah, and it's just the tool.

