---
# Note: This is a metadata section formatted in YAML. This document can be rendered as markdown for better readability.

participant: 25
role: Lead designer
experience(years): 12
instrument_count: 30+

instruments:
 - whole Bastl Instruments product line

langugaes:
 - c++

---
# Why do you use your chosen programming language(s)?

Um, I basically got into this whole endeavour of through Arduino and coding for Arduino, which is basically c++. So there was a natural choice. And I don't know, it's just like the programming language is kind of the default, it feels like for a lot of the like hardware instruments and for programming arm and Atmel processors, that there isn't like really much much of a choice there. Of course, if I work with like some dedicated DSP chipsets, that that wouldn't be a different thing. But I haven't really done that. So.

# Why do you use your chosen tools for instrument design?

So like for hardware design, the choice was Eagle still is, although it's not like an open source. But for saying like, let's say KiCad or whatever, but like, the choice was purposeful, because a lot of the a lot of the designers that use this, and we're open sourcing their design, were using Eagle at the time, mainly de facto and mutable instruments. So and there was quite a lot of r&r, like, you can look at the footprints, wood components today by, you know, a lot of the mechanical stuff as well. But then also like, you look at the schematics and you can like see how they do circuit design. When I was starting, I was actually using fritzing, which doesn't seem to be like very great software for bigger projects. It's like great for like learning and workshop type type type stuff. But then, really, for more of a serious design, when you don't really want to make mistakes, it's ego kind of just works. For that, at the moment, I'm not really planning to switch to KiCAD anytime soon. For software tools. I'm coding mostly either in Arduino if I want to be if I want to, like publish the code like as with the custom, so people could could actually go in and I get so I just use the native programming environment. So So basically, just to make sure it's like easily, like hackable from anybody who is in that sort of world. But for anything else, I'm using Eclipse, and I'm just compiling it with the custom make files. And that's mainly for the reason of like being able to use boot loaders, custom boot loaders, which is something that's a bit more complicated to do like in an Arduino.

> You also mentioned in your survey things like your music studio, and Ableton Live and stuff like that as well.

Yeah, so my, like part of my music studio is very like dedicated to like testing the instruments that we build. So I've got a bunch of modules since there are machines, keyboard instruments, and stuff like that. And then I have a part of my studio that I actually use for my music. And that that one is, you know, basically built around my life set and I I use Ableton to record. Yeah, I don't know, if you want to know, like, What instruments I have or

> Ah, more, how does that influence the like? Does that play a role in, what tools you're choosing to integrate in that?

where Well, yeah,

I mean, like, specifically, I have this drum machine, Roland boutique, what is called tr oh eight. It's just like the very basic 808 thing, but it has like MIDI output, and he does an oak block output. And it's a very stable drum machine that's like really good for testing, in my opinion. So I bought that one just solely for like testing purposes. I've got some, like eurorack modules that I have, just because they are great for testing, like the mod x data, or w empty spectrum, or silvitra. I could also do make noise. Zero coast, that's also my like, go to like testing this thing thing. Yeah. So these these machines I own because, you know, for us, they're good for testing. And second, they are kind of like a recognisable visual representation of you know, like, the other gear that this that our instruments could be used with. So when, when I make product videos, I end up using those quite a lot. Because people often ask, ask these questions whether whether they're compatible, and so on. 

# Why did you chose your chosen platform(s) to build your instrument on?

So now you mean the Arduino for instance. I mean, that's, that's the platform that I learned the, the art school that I was studying in, so I don't have a proper, like engineering training. So that and that was kind of aligned timewise. So when I was learning, this was pretty much like the only thing you could like learn like 10 years ago, or 12 years ago, whatever. And he was there, it was, like, what it was like really quickly, developing a lot of interesting libraries to get things done quickly. So that was a platform of choice. I still think it's really good, good thing, if, if you approach the open source aspect, from the perspective that you want people to like, look inside and want to hack it, that's like a low threshold for anybody without like, that, like for more technical training, so for, let's say, artists, or musicians, which also so that would be like the choice and the, the other like platforms, I basically, because I do work with, you know, formally trained engineers. It's basically influenced by the tool of tools of choice. So I basically like adapt. We use GitHub for GitHub and get lab for for the versioning. And also, for issue tracking. It's mostly Git lab now.

> You describe using Arduino because it's very accessible? Is there a reason then for for moving to ARM which you also mention?

And I use the Yeah, so with Yeah, well, basically, it's like the sort of like price to like, performance ratio. So a lot of the more advanced instruments that we've built are based on the arm chips.

And that's because yeah, they're like power efficient, they're powerful enough to run and those tasks so pretty much like a lot more that you can do with the AVR stuff.

# Are there any other tools (software or otherwise) that you feel contributes significantly to your process?

Um,

I mean, I do a lot of the like concept design in Illustrator. And so I do a lot of work all of the panel design in Illustrator or like, basically sketching like the the first draft of the interface. So that's like a programme, I, again, learned that art school and I've never really had a reason to switch. So that's that I think that one is quite important for, let's say the less engineering type of the design that I do. A lot of it is done in Illustrator. And often it's like going back and forth between ego and illustrator and coming up to the final shape. 

> Because, I think maybe that's is quite an influential part of your instrument design. Right? The the aesthetic as well. 

So, yes, absolutely. I work with a design studio that does mainly graphic design. So I mean, I, I do the interface design to layout and they kind of give it the facelift. If they're graphic design, and we've been working together for nine years now or something it's like, so it's really easy to work with them. And they already know, and one of them is also a musician, so it makes it up. 

# What would be the biggest 'Quality of Life' improvement you could request from your tools for designing DMI?

Okay, I'm not sure if I'm getting what you're asking for correctly. Are you asking for like, what would make my life easier when working with those tools? Okay, I get the question. Let me think for a second. Think like, what would be cool? In general, let's say for the hardware design, if there was like a bedrock like versioning implementation, because it's kind of hard to review changes in Eagle, let's say if you use GitHub

that I think would be like the biggest improvement in the workflow if I could easily see some sort of like versioning system implemented in Eagle. I think I might have like noticed, they were working on something like that, but I'm not really sure.

I mean, for the software side, because like all the code is like text based. And those tools are made for like reviewing the changes in the text. It's already there. So like for writing firmware, and for the versioning cue, you can review the changes easily.

But yeah, that is non existent. It would be really cool. It's a really, really nice idea.

> would that be something that you'd like to match up to firmware then as well, so that you can synchronise versions? Would it? Would it be to integrate with the software side or just purely for the hardware development?

Yeah, I don't think that is really like a good connection. Because you have every time you need to do a 3d by hand if you like design a piece of hardware, you don't need to do like all the mapping of the hardware or basically writing the drivers you just need to do it by hand when referencing the schematics. If something like that existed, that will be amazing. However, it doesn't usually take that much time to really like you know, just for, you know what I'd done the port names by hand and Anyway, so that usually isn't like, the thing that we spend a lot of time in anyway. But it would be nice. It would be nice. Yeah.

> Yeah, you don't iterate a level, that means that that would benefit Really? You don't iternate the hardware enough to do that?

Yeah, not really no. I mean, would be nice. But, you know, for instance, when when I'm writing, when I iterated the hardware, then like any software that I write further on, will not be compatible with the with the previous hardware prototype. But sometimes it would be nice to have it like back compatible or like, have it have the have the compiler, let's say automatically detect which version of a hardware I'm building for. Not that you can't really do it by like writing it. In the code, you can definitely like use some pre compiler. scripts. But yeah, I don't end up doing this because I'm lazy, I guess. But if the software did it for me, then I would probably use it.


# How do you approach the design of a new instrument?

It's really from from an instrument than instrument, sometimes it's a collaboration. Recently, we've been approaching a lot of, we've been like doing a lot of v2, or like, you know, second iteration of the design idea, basically taking an existing design the v1, let's say it was successful in some ways, and then like seeing like, Okay, what would the does the user base usually complain about what we don't like about it? So then it's like, very, like market informed. And you have, you have a lot of data from the user base. Usually, if you do v two, that's kind of easy. If you're doing version one of something a lot of the time, you will just, yeah, you you have your own network to people you can talk to, I know quite a lot of musicians. So I can, I can talk to people and maybe like show them early prototypes, there is a lot of musicians in the company itself. So but from my experience, sort of those people are not, they don't have that mindset of like telling you, like exactly what to do in terms of interface design. A lot of like, people are just like used to like, learn what to how the tool is come in, or how to instrument is communicated them, they like us to learn that language. And then like can, you know, then just submit to that. So a lot of people don't have that mindset of like thinking like how things could be done differently or better. So that often is quite a close. I don't know that there's not that many people I can talk to about like, really? The interface design itself. It's mostly really like learning from from other companies products, I don't know, like you can look at electron and what electron is really successful in achieving it or teenage engineering, and like how they're improving on the electron workflow, but making more intuitive and like, what type of trade offs does it bring. And then like also looking at what, what really excites me like what type of interfaces I would like to see used in those workflows that the existing products don't offer, really. So a lot of data was kind of bogged down in the mediaeval era that we released recently. Although that one was in development for let's say, like three years, but the focus there in the interface design was delayed for like immediacy and capturing ideas, like really quickly and building another rapidly like iterating on musical ideas, which is when when you're doing to looping workflow, which I think is really useful. Because a lot of those, like sequencing based machines are often based on like making that like one perfect loop. And it's not that easy like to just start over. So That was like a clear inspiration. I'm doing a lot of like, I'm not even sure what the original question was.

It was questions. So, and basically, it's very different with every single instrument. So.

> I think it's interesting what you're saying about the v2 as well, perhaps this suggests that an instrument is never really done, there's always like, a room to keep going with it. 

Um, yeah, I mean, at some point, you really need to like sub, you know, you need to submit, you need to, you need to go for it. And I think I'm quite good with, like submitting to something that's like, Good enough. So I'm, I'm not like, in some sense, I'm not a perfectionist in in some other senses, I am, but I know, like that, like, the v2 is always gonna be better. And maybe it's gonna happen in three or five years. But if it's gonna happen, you know, if there is if the instrument itself still like sparks that excitement, I think, I think then, like, deserves the veto.

> Just making the sort of minor incremental changes that improve it based on that data.

Yeah, yeah, as well. And also, like the real real world usage. So, I mean, you know, my studio changes, like, gradually, you know, over the years, so, when I'm designing something in the context of the tools that are available on the market, let's say in the year 2015, it has like, quite a different, you know, requirements for, let's say, connectivity and interaction with the other instruments than when you're designing something in 2021. So the tools around you are different, the way you want to make music is different. So yeah, and then like, a lot of that can come down to, let's say, version two, thinking.

> I think that's actually a really interesting idea that in some ways, because digital instruments can, you know, they can become obsolete, because the technology changes, it's important to revise them to keep them current as well. Does that make sense?

It makes sense. But like, I don't think they really do get obsolete so quickly. No, I mean, they can become obsolete by being replaced by version two of the same manufacturer or buying overshadowed by the product from another company, but if they actually are a good, a good design, people will still come back to it. I mean, you can, like look at look at, for instance, like the machine drum or the mono machine by electron, which by, you know, the design thinking in electrons had would be like, way too ancient, and like, way too bad, but it still has, like a cult user base, and those machines sell for, like really high prices. Because that sort of how to say that sloppiness of the interface, like made people like, let's see, Sophie, make certain type of music with it, just because the interface was done in like, various training way. And I think, you know, also, like, we've seen, like, a lot of pre issues of the Tb 303, which is like the worst terrible sequencer ever. But like, because it was so bad. It made you do certain patterns that you would never think of, you know, it's like very bad, in a sense that you vocalise the baseline and then you try to programme it, it's like, close to impossible. So now you have you. So now you have like, loads of these, like, new iterations of the Tb 303, which actually improve on that, it's like, you can just like record the melody. But then, in some sense, like the sounds from these are like the, the patterns people end up using, and these are like, boring, in a sense, you know, because they're like the thing that you can easily imagine it's not like the bad interface that like forces you to do something that you would never come up with. So Yeah,

# When creating a new instrument, what distinct aspects are required to realize the design and implementation?

yeah. So like, it's very like diverse, I will probably not talk about eurorack modules, because you're specifically asking about instruments. So, let's see. So if it's, if it's a purely digital instrument and not like a hybrid thing, then a lot of the times, what you're looking at is, if the architecture you're choosing is, is powerful enough, it can have like enough compute computational power, or like, if it can access, let's say, the memory in short enough time period, or if it has enough memory, so you like, basically try to calculate the, the highest specs you would you would want and then then you're looking at the architecture. And if you already have a have, like the sketch of the interface, you already know, how many inputs you would need from all the hardware components. So and basically, you kind of know like, how many digital to analogue converters or A to D converter as you would need. So with with digital instruments, it's very often like you have a sketch, and then you go for the implementation. But if he if we're doing something like hybrid, that's like semi analogue semi digital, it's like a lot more messy. basically, it's a lot of the time it comes from, let's say, like, make a batch on a module sent, and you have an idea for a specific sequencer. So you kind of prototype it as a as a batch, let's say the analogue the analogue bit, and maybe then you have some sort of sequencer or you you think of different type of sequencer interface. And then you try to, like put it all together somehow. So these hybrid digital analogues are, I don't know, somehow a bit more messy and a bit more a bit more hard to describe, you can't just like sit at the computer and draw, make a drawing in Illustrator and know, what do you need to look up? Like in the data sheet? It's not really like that. So I don't know. Yeah.

> So then, once you've got that technical basis, to build upon what what what are the distinct things do you have to do before you end up with a completed product?

Um,

well prototypes, you, you make the first prototype, you learn from it, you make the second one, and then you make the third one. Sometimes it's just two prototypes, it depends on the complexity of the instrument, really, but let's say if, if I'm looking now at the middle Oprah, which is like very like interface, it really tries to like simplify the access to certain functions. So everything that you want to do in real life has to be done like with a single gesture, then, basically, I was testing it in the in the real life scenario and seeing if there is a button missing or what would would like what it would do if this switch was a button instead, or things like that. So if it's, if it's something that is like very, like, three based on the ease of access, like the main loop is, then most of the iteration is is done on the interface level, but then like with, I don't know, instruments, like the time which is the effects processor, it has, you know, you're sort of like maximalist approach. Let's Like put like enough interface components for every parameter and then like just like, make it as best as we can. But yeah. But it's interesting because like now it's like that kind of instrument that would certainly deserve a v2. And then basically like that one was like, the time it's like the maximalist prototype that's like, everything you would want. But like, it's not like, it's sometimes like not the most useful way of designing things. So like now that we have that, it's kind of easy to cut, cut from that. So. But usually, it's the other way around on the middle Oprah, for instance, I usually ended up like missing a button. On the time, it's kind of the opposite is that, like, we gave it like enough buttons to satisfy whatever need because we didn't really know what we were designing. I mean, we had to had the basic idea. But the whole process was very experimental. And we redefined like, what he does, like when we were coding it, like so many times, before we arrived to the final thing. So I mean, what what we do at pasta is that is like load of like experimental, and innovation part. And those are like very messy processes. So like, sometimes you make the prototype, and like putting, like one more knob, and you don't know what it's gonna do, like, you just put it there. Because like, you already know, because you might be missing a knob at some point in the future, because sometimes you'd like me to write the code, and see what's interesting about it and what's not. So, I don't know, something like that.

# What do you consider to be the biggest challenge when designing an instrument?

Um,

I guess like, most of the stuff that I design, I don't design it alone, I work with other engineers, and usually the communication. So that's usually the most challenging. Because like, if, if you for instance, work with, with trained engineers, on on something so Maxi, like those experimental instruments that we do are, like, a lot of times the engineer's they want like, clear, clear, like feature set, you know, define everything on the paper first. And then we do it. So then, like, when you have everything written down, you can think of the architecture and you make robust architecture for that. But a lot of the times in what we do, like you need to go back, after something's done after you tested in the real scenario, you kind of need to back and like change the architecture, and the engineers like hated that, you know, it's like, but I don't even know if it's possible to do it the way that they would like to do it. I think most of the people I work with, they kind of accepted it as a fact. It's kind of impossible with some of those machines to like, really define it unless it's like really easy or simple to So yeah, I think expectation management between all the all the designers, engineers, and the communication usually like the hardest part. Sometimes also like motivation. Same But usually, it's not the technical stuff you get stuck on, I would say.

# What tools do (or could) play the biggest part in helping with these challenges?

I mean, certainly like the issue tracking, like on Git lab that you write down like everything and you have a structured conversation is probably the single biggest like improvement in this process. And also because we don't all live in one city. That like makes it like really important important to buy Like they're in this sort of environment, it's it's not like not to say it. It's not good for everyone, psychologically, let's say because like, I mean, I work with Peter Edwards, Casper atronics. And I also am sort of like the art more of artsy person. And a lot of the times when, when the, when the communication is somehow distilled to like, this very, like very good a system, when if you resolve something just like disappears, it's like really demotivating. And sometimes you get really annoyed by like somebody like writing something up there. So trying to like sort of clear up the emotional baggage that those systems that are like developed by coders who probably don't like really need the empathy layer, or like the human touch to that communication. Yeah, that I think is hard. Especially now, like in the COVID, times, when we don't see each other, you know, in person, it's really difficult to communicate just through these, but you kind of like really need need to have the structured conversation, what every single like aspect of the instrument in you need to have it. But, yeah, it's very, like inhumane, and I don't know.

> Do you? Do you find that there's any sort of like chat or social applications? Do they play a part then in that?

Well, we use slack. But so you can have it for like, some conversations, but like, it's not the best for like keeping track of, like, what needs to be done. So if you need to discuss something like you can use the chat, and it's better, it's sometimes better to call the other person. So like, we use that as well. But I kind of wish the issue trackers were designed with more humanely around.

It's like with the to do list apps, you know, like a lot of the times, like, what do you what do you have done, it just like disappears, so you don't really like you don't immediately see like what you've done. So you can't be like you can't really like it doesn't give you the option to feel good about what you have done. It just always gives you overview of all the shit that you have to do and that you have resolved. And that's so that and like this sort of in a humane way of how people assign you certain issues. It's like combination of those things that doesn't make it like very pleasant environment to work in. But it's like, it's like super important. And like, it greatly improves the workflow. But yeah,

# How would you define a DMI?

yeah. Okay. Well, I would define it from the perspective that it's, it's running some sort of clever code that allows you to greatly increase efficiency. Because for example, for instance, with the costume, it's it's digital, but it it has like all analogue interface. It's like nothing digital about the instrument. So although it's implemented digitally, I don't see it as a digital instrument. Probably like if you if you put the question that way, I'm not sure if it's like very useful to have that definition. But for me, really like the the interface, whether it feels analogue, or it feels digital or both. Let's say one part of the instruments feels like very analogue, another part of Europe feels very digital. And by digital, I mean, the controls could be conditional. They can do different things in different modes or Or if it's like buttons that access menus and stuff like that or change settings? Yeah. Well, there is a certain field, let's say two analogue interfaces like in the eurorack, you have a lot of digital modules, what they feel and using them feels like using an analogue analogue instrument because everything has a knob, and let's say your CV input. So I wouldn't really like consider that. A digital instrument.

> Right, even if that is a eurorack, a eurorack module that is entirely digital, you wouldn't consider it a digital instrument if it _effectively_ emulates the analogue instrument?

let's take the analogue instrument interface, not not, let's say like not the sound or not the function, let's see set some, let's say either envelope generator, just friends from mannequins, it's like six envelope generators, and they are interlinked and implementing something like that. In analogue it's not impossible, but it's like really, really difficult. But it has like very analogue interface. So you can, like interact with it as if it was an analogue, or some digital oscillator he had that like, feels like very analogue, because but but the sound is digital. So it has the digital character, the sonic characteristics, but the interface is like really like all analogue. So I'm not sure if I consider that. Yeah, I would go on to the debt and digital instrument. On the other hand, like, for instance, the arturia micro freak, although it has an analogue filter, and analogue, whatever, I don't really consider it an analogue instrument, because like, you know, you can store all those settings as a preset and it doesn't really feel very analogue.

> So  for you, it's, is almost like the interaction model, that you're the plays with big part in this is the ability to, like, have all that logical operation going on in the digital side of things versus the just very direct mappings in analogue?

Yeah, I think it's that experience of using the instrument that kind of speaks speaks to me more than the actual implementation. Because like, if you, if you, like, from my perspective, really try to go and like, look for the borderline between digital and analogue. It's official territory. And like, for myself, I did define the digital that runs a piece of code. But then, like, if you're asking about instrument, if it's a digital instrument, then instrument is about an experience of playing the instrument. So it really is more about the experience rather than the implementation from my perspective. 

# What concepts do you consider a DMI to be made up from?

Yeah, I'm not sure it's, it feels like a bit of an arbitrary definition, but I understand like, like, defining certain concepts is like very useful for academic purposes. I kind of assume that's like what you're trying to do with your study. But I'm not I'm not really sure if it's a very like interesting concept for me as a designer, like really know the definition.

Okay. Let's say preset ability that you can create presets, that would be one sequencing, all those sequences could be implemented in an analogue fashion. And you have like analogue sequencer interfaces, I think like, the whole idea of sequencing in general, if it's like, not fits like bit more advanced that that's very like digital concepts to me. Although it could be implemented in analogue, like, let's say the zero control from make noise, I think it's implemented or in analogue. But it kind of doesn't feel like that, for me. It's like the fact that symptomatic analogue is kind of arbitrary. here for me. I think button combinations. That that might be one aspect. And maybe macro control that you have, like one, one control that affects several other parameters at once.

Yeah,

it's kind of funny, because like you, you have these, like, macro controls even on like, analogue instruments on analogue modules. But whatever the times they end up like feeling very digital, in some sense. Yeah.

> So so the things that you've described, there all seem to be like a control related component. Yeah, yeah. Do you think that's a big part of what makes up a musical instrument, an electronic musical instrument or a digital musical instrument?

Yeah, if you're asking about musical instrument, it, it really is about the way how you interact with the instrument. So it is the experience. So the more you like, look into digital ones. I think a lot of the times you end up with those, like Andhra and less controllers like encoders. And some displays that like show you the values, that's like a very digital concept. But, yeah, let's say like on an electron machine, with those endless encoders, you always need to look at the display to actually see what you're doing. So what that that doesn't really, that makes it like really flexible, but on the other hand, it doesn't make it really good as a musical instrument, it's more of a programming interface, rather than a musical instrument, like a lot of the electronic machines, because you really need to fixate your vision on the display. So, so you can't really be multitasking when when you interact with those. So it's like, it's really hard to keep, like visual contact with the audience, when you're performing and interacting with the electoral machine at the same time, it's like impossible, but like, it's like, really easy to play an analogue send key, maybe like play the keyboard with one hand, tweak the knob with the other and still keep, like visual contact, you know, so that sort of, like, multitasking, I think, or at least that's, like, for me, like a very important aspect, what, what makes a good instrument doesn't matter whether it's analogue or digital, but if it like really requires your vision, or like, the attention of your eyes, I, I don't think that's, that's, I don't think that's like necessarily good. From from, you know, good incense, it doesn't make it a good instrument. I think like the good balance, it's like somewhere in between where, where you have combination of those that you don't really need to, maybe you don't have the endless controls, but you have, you know, regular potentiometers but then, like for some settings, like I don't know, setting up the MIDI channel or whatever things that you don't really do during the performance, you might use a display or something like that. So, and some some instruments are better at that than others. I kind of tend to like fix that. About Some of the instruments that I use for live performance by making myself custom MIDI controllers, I made one for the Opie's that. And it just is like eight knobs with the central detent. And they're like filter for each of the tracks. I'm not sure how familiar you are with the opposite. Yeah. So I have this, like physical physical controls that I can like, just use the filters to like fade in and out different sections. without really like looking at the instrument, and being able to, like have it fully open, like the filter is fully open when done when the port is in the centre detained. And I really use that a lot. That's like, like one hand controller that I built for myself. And that kind of relief fixes me like that, that was makes it possible for me to use the Opie's that in a live context. I mean, the opposite is a brilliant instrument is just like not very, like, performance oriented, or like not that you're like multitasking oriented. You know what I mean? I don't know. 

> So that that kind of, in a way, it seems that you've got another kind of concept there really? And that you can, I don't know, like extend the interaction by MIDI or something like that.

Yeah, yeah, maybe you can do a lot of that you can fix a lot of the things that you won't be able to fix otherwise, like, for instance, on the OP set, you said you had one or you played with one, you know, so for instance, there is this like weird thing that you can mute certain tracks.

But every pattern remembers the mute states. So if you're performing, you kind of need to remember which button has which instrument muted. If that makes sense. So like, I made this sort of, like, on the controller, I have like mute buttons. And then I have also buttons for switching patterns. So but then, like I can, what I can do is that like, as soon as I switch a pattern, it also sends out control messages for all the mute states. So it updates them in the machine, regardless what like what what was their initial state in the machine. So I can like be in control, like, which instruments are muted, and I don't really need to think of that. 

> would you would you say that that idea of like that, that ability of a digital instrument to be dynamically? moldable? Would you say that's an interesting concept that is unique to digital instrument?

Yeah, absolutely, I think the MIDI control and like making custom controllers, I'm really into that in the past, like, let's say two years, I like I love making MIDI controllers, basically just to fix the aspects I hate about the about the instruments that that I'm using, like I built a custom controller for an auto tune machine can show you that it's like instead of think that I can put the microphone in here and then like hold it in my hand. It is the media out and I can like play define certain notes for the auto tune. And I can like sing and define the notes like this. And then like I'm playing the outer tune in sort of a way how you would play a flute in some sense but it only takes like one one hand to do that so yeah and build the thing for the opposite and now I've got this like electoral machine and I'm like constantly thinking what kind of controller I want to build for that because you know, always annoys me like how certain things in the interface are designed so I don't know I haven't seen a lot of people doing that there was this like movement of making custom controllers for for computers which was my arm maybe I needed to go eight years ago on the controller isn't that was like the buzzword with people like Moldova, and Tim exile, making like very custom controllers for let's say max MSP patches, so they could like play So it was sort of like a hybrid design of the to design a patch in Max MSP, you then you build a custom controller to do. Yeah. Yeah. So that was kind of a big thing. And now I'm locally all about making those custom controllers for those hardware machines because I don't know somehow I still like not really using the computer in my live sets.

